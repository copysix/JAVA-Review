8.锁

8.1 什么是同步，什么是锁

8.2 Synchronized

8.3 ReetrantLock

8.4 Volatile

8.5 可重入锁

8.6 乐观锁和悲观锁

8.7 自旋锁

8.8 无锁 偏向锁 轻量锁 重量锁

8.9 公平锁和非公平锁

8.10 读写锁

8.11 独享锁和共享锁

8.12 分布式锁


2. synchronized 通过monitorenter和monitorexit指令来同步代码块，monitorenter指向同步代码块的开始位置，monitorexit指令指向结束位置
synchronized修饰的方法或者代码块，在多线程访问时，如果监视锁monitor发现已经被占用，那么其他线程就会被阻塞，如果线程执行了monitorexit就必须要释放锁
synchronized锁是可重入锁，例如当synchronized修饰对象（对象锁）时，其它调用这个对象的线程也能获得锁，也就是说是可重入锁

3. ReentrantLock
手动lock和unlock，如果线程获取锁（调用acquire方法）尝试未果，最多等待1s，说明此时锁被其它线程占用了，ReentrantLock会返回false，此时线程就会去执行其他任务，而不是一直被阻塞。
ReentrantLock也是可重入锁，并且还可以实现公平锁

4. Volatile
Volatile告诉线程该变量在工作内存中的值不确定，需要到主存中取，保证可见性、有序性，不保证原子性

7. 自旋锁和非自旋锁
当线程在获取锁时，发现锁已经被其他线程占用，那么就会循环等待，直到获取到锁，该线程一直处于活跃状态，而不是阻塞状态，相比于非自旋锁来说，避免了从用户态切换到内核态再切换到用户态的这些过程，减少了不必要的上下文切换。但是自旋锁没有办法保证等待中的线程一定可以获得锁，这样就很有可能出现某些线程等待时间过长，一直无法获取锁的情况（“线程饥饿”）。


