1. Java基本特性
# 目录
# 1.1 谈谈对JAVA特性的理解

# 1.2 谈谈对泛型的理解？（参数化类型）

# 1.3 抽象类和接口的区别？

# 1.4 重载和重写的区别？

# 1.5 如何理解构造函数不能被重写



1.1 谈谈对JAVA特性的理解

抽象：将一类对象的共同特征提取出来的过程。

继承：从已有类中得到继承信息并创建新类的过程，是封装的可变因素。

封装：将数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。封装是封装一切可以隐藏的，只向外界提供最简单的编程接口。

多态：允许不同子类型的对象对同一个消息作出不同的响应。



1.2 谈谈对泛型的理解？（参数化类型）

泛型即“参数化类型”，将类型进行参数化，什么叫“参数化”呢，平常的参数有形参和实参，当调用方法的时候，才传入实参。泛型对类型的参数化也是同样的，它相当于模版，将需要使用的数据的类型参数化，当真正使用时再传入具体的类型。泛型适用于对多种不同类型的数据进行相同的操作。

包括 泛型类 public class classA<T> { T data; T getData(){return data;} }
        泛型接口 public interface interA <T> {abstract T next();}
        泛型方法 public <T> T  getData(classA<T> data) {return data;}
        泛型通配符 public void showData(classA<Number> obj){}
                           public void showData(classA<?> obj){}  // 此处 ?相当于实参，是实际类型




1.3 抽象类和接口的区别？

抽象类和接口都属于“抽象层”，都不能被实例化。
1）抽象类是类，一个子类只能继承一个父类，但是能实现多个接口

2）Java里类的继承是单继承，为了避免多继承的二义性，但是接口的使用也可能会有二义性，因此在调用同一个接口的相同的方法时，需要指定是哪一个接口的方法，例如 class C implements A, B{public void test();}调用时： (A)test, (B)test,这也是接口里出现默认方法以后带来的不变之处。当接口的默认方法和父类中同名时，默认以父类为主。

3）抽象类里不一定有抽象方法，也可以有非抽象方法，但是有抽象方法的类一定是抽象类。抽象类里的抽象方法一定要被子类重写，非抽象方法不用。而Java8之前的接口中只有抽象方法，这意味着接口里的方法必须要被实现（抽象方法在类或者接口被继承后一定要实现）。

4）但是在Java8里，接口里可以有实现的方法，一个是接口默认方法，一个是接口静态方法，静态方法不可以被重写，要调用只能用 interfaceName.staticMethod()的方式调用。默认方法用default修饰，默认是被继承了，可以再在实现类中再重写，不重写也没关系，因为已经默认继承并且在接口中已经实现了。Java8在接口里添加默认方法和静态方法，主要是因为如果想在接口中添加新的方法，按照Java8以前只能新增抽象方法，抽象方法需要所有的实现类都实现，这样可扩展性不强。

5）接口主要是为了弥补Java中无法多重继承的特点，针对的是对象而不是实现，具体的实现交由实现类来完成。

6）类继承主要是表明子类“是” 什么， 接口实现则是表明实现类“有”什么， 抽象类更集中在对象本身拥有的特性上， 接口更集中在对象后天的行为上（自己的理解哈）。



1.4 重载和重写的区别？

1. 重载（overload）是在一个类中，方法名相同，但是参数列表不同，返回类型可同可不同。
重写（overhead）在父类和子类之间，方法名相同，参数列表要相同，返回类型可以相同（Java5之前要求相同），可以不同（子类的返回类型是父类返回类型的子类）

2. 重载必须要改变参数列表，但是被重载的方法可以改变返回类型、可以抛出范围更大的异常、可以改变访问修饰符。
重写的好处在于子类可以根据自身需要来定义自己的行为，但是其返回值类型要么和父类相同、要么只能是父类返回值的子类。同时，在子类重写的方法中不能抛出比父类异常范围更大的异常，比如父类方法中声明 IOException， 子类方法中如果是声明了 Exception， 会报错。重写也不能随意修改 访问修饰符，只能比父类访问权限更松，父类如果是public，子类也必须是public。父类是private，子类则可以是private、protected、public

3. 如果子类和父类在同一个包里，子类可以重写父类private的方法，不在一个包里，则只能重写父类protected和public修饰的方法。声明为final和static的方法不能被重写，构造方法不能被重写。

4. 覆盖是指子类对父类同一个方法名，相同参数列表、相同返回值的方法的实现。其实也是重写。



1.5 如何理解构造函数不能被重写？

构造函数用于初始化成员变量和成员方法，相当于一个类的特定的标志，有了这个标志以后就可以创建新的对象。如果被子类继承，就说明子类也可以创建这个标志的对象，标志就不再唯一。事实上规定类的构造函数需要与类名同名也无法让子类再重写父类的构造函数。



