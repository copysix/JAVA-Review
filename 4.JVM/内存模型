4. 内存模型

4.1 JVM 内存模型和每一块作用
共享内存区（堆，方法区），线程私有区（JVM栈、本地方法栈、程序计数器）

4.2 jdk1.8以后JVM的变化

4.3 JAVA类加载机制
（加载、验证、准备、解析、初始化）

4.4 JAVA内存模型（主内存和工作内存）

4.5 JAVA主内存与工作内存的交互

4.6 从JAVA内存模型看原子性、可见性、有序性

4.7 垃圾回收算法
标记-清理、复制、标记整理、分代回收

4.8 Full GC 和 Yong GC 、 Old GC

4.9 GMS和G1


Yong GC: 当新生代区满了以后触发,采用复制算法来回收垃圾，会先检查老年代的存储是否足够，如果老年代也装不下就会触发对老年代的Old GC，先腾出一些空间，然后再执行Yong GC

Old GC: 老年代空间不足，没法放入更多对象，这个时候务必执行Old GC对老年代进行垃圾回收。不管是Yong GC 检查时触发还是说老年代里的垃圾本身占比达到某个值（92%，也可以自己改变）就会触发Old GC
Old GC 采用标记-整理的方式，还需要从根节点开始对所有可达对象进行标记，再将存活对象移动到另一边后再标记。可见内存利用率会变高但是Old GC花费的时间很长。

Full GC: 包括Yong GC和Old GC，例如上面的情况当进行Yong GC时又触发了 Old GC，实际上也是Full GC


